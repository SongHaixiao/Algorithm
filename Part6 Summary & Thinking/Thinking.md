# Thinking

## 1. 除留余数法

[Reference](http://www.nowamagic.net/academy/detail/3008040)

JDK hashMap源码，hash表中数组位置的计算分两步：

1. 计算hash值：

  ```Java
  hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
  }
  ```
  这一步有一种说法，叫它扰动函数，为什么要右移16位再与本身异或呢？

   - 首先hashCode()返回值int最高是32位，如果直接拿hashCode()返回值作为下标，大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般是很难出现碰撞的。问题是一个40亿长度的数组，内存是放不下的。

   - 所以，用自己的高半区和低半区做异或，混合原始哈希码的高位和低位，关键是以此来加大低位的随机性。为后续计算index截取低位，保证低位的随机性。

   - 这样设计保证了对象的hashCode的32位值只要有一位发生改变，整个hash()返回值就会改变，高位的变化会反应到低位里，保证了hash值的随机性。

2. 在插入或查找的时候，计算Key被映射到桶的位置：
  
  ```Java
  int index = hash(key) & (capacity - 1);
  ```
  hash()扰动函数计算的值和hash表当前的容量减一，做按位与运算。

 - 为什么要减一，又为什么要按位与运算？

    因为 `A % B = A & (B - 1)`，当B是2的指数时，等式成立。

    本质上是使用了「除留余数法」，保证了index的位置分布均匀。

 - 为什么HashMap的数组长度必须是2的整次幂？

    数组长度是2的整次幂时，（数组长度-1）正好相当于一个**低位掩码**，**与** 操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。

    以初始长度16为例，16-1=15。2 进制表示是00000000 00000000 00001111。
    
    **与** 操作的结果就是截取了最低的四位值, 也就相当于取模操作。