#  基数排序（Radix Sort）

再来看这样一个排序问题。假设有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，有什么比较快速的排序方法呢？

之前讲的快排，时间复杂度可以做到 $O(nlogn)$，还有更高效的排序算法吗？桶排序、计数排序能派上用场吗？手机号码有 11 位，范围太大，显然不适合用这两种排序算法。针对这个排序问题，有没有时间复杂度是 $O(n)$ 的算法呢？现在就来介绍一种新的排序算法，基数排序。

刚刚这个问题里有这样的规律：**假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。**

手机号码稍微有点长，画图比较不容易看清楚，用字符串排序的例子，画了一张基数排序的过程分解图:

<img src="../Resources/31.jpg" style="zoom:40%;" />

注意，**这里按照每位来排序的排序算法要是稳定的**，否则这个实现思路就是不正确的。因为如果是非稳定排序算法，那最后一次排序只会考虑最高位的大小顺序，完全不管其他位的大小关系，那么低位的排序就完全没有意义了。

根据每一位来排序，可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 $O(n$)。如果要排序的数据有 k 位，那就需要 k 次桶排序或者计数排序，总的时间复杂度是$ O(k*n$)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于$ O(n)$。

实际上，有时候要排序的数据并不都是等长的，比如排序牛津字典中的 20 万个英文单词，最短的只有 1 个字母，最长的特意去查了下，有 45 个字母，中文翻译是尘肺病。对于这种不等长的数据，基数排序还适用吗？

实际上，可以**把所有的单词补齐到相同长度，位数不够的可以在后面补“0”**，因为根据[ASCII](https://zh.wiktionary.org/wiki/US-ASCII) 值，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续用基数排序了.

## 总结

基数排序对要排序的数据是有要求的

1. **<font color="orange">需要可以分割出独立的“位”来比较，而且位之间有递进的关系</font>**, 如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。
2. **<font color="orange">每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 $O(n)$ 了</font>**。



# 思考

> 1. 如何根据年龄给 100 万用户排序？

实际上，根据年龄给 100 万用户排序，就类似按照成绩给 50 万考生排序。假设年龄的范围最小 1 岁，最大不超过 120 岁。可以遍历这 100 万用户，根据年龄将其划分到这 120 个桶里，然后依次顺序遍历这 120 个桶中的元素。这样就得到了按照年龄排序的 100 万用户数据。



> 2. 假设现在需要对 D，a，F，B，c，A，z 这个字符串进行排序，要求将其中所有小写字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序。比如经过排序之后为 a，c，z，D，F，B，A，这个如何来实现呢？
>
>    如果字符串中存储的不仅有大小写字母，还有数字。要将小写字母的放到前面，大写字母放在最后，数字放在中间，不用排序算法，又该怎么解决呢？

- 方法 1 ：

用两个指针a、b：a指针从头开始往后遍历，遇到大写字母就停下，b从后往前遍历，遇到小写字母就停下，交换a、b指针对应的元素；重复如上过程，直到a、b指针相交。

对于小写字母放前面，数字放中间，大写字母放后面，可以先将数据分为小写字母和非小写字母两大类，进行如上交换后再在非小写字母区间内分为数字和大写字母做同样处理

其实第二个问题还可以优化一下，借助插入排序的思想，用两个指针分别从数组的最前面和最后面向中间遍历，这两个指针分别标记小写字母区间的最右侧和大写字母的最左侧；当小写字母和小写字母分居两侧后，中间部分自然就是数字了。时间复杂度为O(n)。

- 方法2：不用排序算法，就直接遍历一遍，比较ASCII码

- 方法3：利用桶排序思想，弄小写，大写，数字三个桶，遍历一遍，都放进去，然后再从桶中取出来就行了。相当于遍历了两遍，复杂度O(n)



*`@ 笔记时间 ：2020-8-23	FROM	极客时间 《算法啊与数据结构之美》 王争  专栏`* 