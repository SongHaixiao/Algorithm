# 二叉树 （Binary Tree)

## 介绍

二叉树，顾名思义，每个结点最多有两个 **叉**, 也就是两个子节点，分别是 **左子节点** 和 **右子节点**。

不过，二叉树，并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。

<img src="../Resources1/33.jpg" alt="Figure" style="zoom:40%;" />

## 特殊二叉树



- `满二叉树`：叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做满二叉树. ( 如上图 编号 2)

  

- `完全二叉树`：叶子节点都在最低下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大.(如上图 编号 3)

<img src="../Resources1/34.jpg" alt="Figure" style="zoom:40%;" />

## 如何表示（或者存储）一棵二叉树？

### 两种方法：

- 方法一： 基于指针或者引用的二叉链式存储法；
- 方法二：基于数组的顺序存储法。

### 链式存储法

- 优点：简单、直观


<img src="../Resources1/35.jpg" alt="Figure" style="zoom:40%;" />

从图中可以很清楚地看到，每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针.只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来.

这种存储方式比较常用，大部分二叉树代码都是通过这种结构来实现的.

### 顺序存储法

把根节点存储在下标 $ i = 1 $ 的位置，那左子节点存储在下标 $ 2 * i =  2 $ 的位置，右子节点存储在 $ 2 * i + 1 = 3 $ 的位置. 

以此类推，B 节点的左子节点存储在 $2 * i = 2 * 2 = 4$ 的位置，右子节点存储在 $2 * i + 1 = 2 * 2 + 1 = 5$ 的位置.

<img src="../Resources1/36.jpg" alt="Figure" style="zoom:40%;" />

**总结：**

-  **X 节点：  在下标为 $i$ 的位置；**
- **左子节点：在下标为 $2 * i$ 的位置；**
- **右子节点：在下标为 $2*i+1$ 的位置；**
- **父节点：    在下标为 $i/2$ 的位置；**
- **一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置.**

通过这种方式，只要知道根节点存储的位置,就可以通过下标计算，把整棵树都串起来.

## 完全二叉树

### 疑问

- 为什么要特意把完全二叉树拎出来讲呢？
- 为什么偏偏把最后一层的叶子节点靠左排列的叫完全二叉树？
- 如果靠右排列就不能叫完全二叉树了吗？
- 这个定义的由来或者说目的在哪里？

通上面对表示、存储一棵二叉树的了解，现在就可以理解完全二叉树定义的由来了。

### 解答

通过顺序存储法，一棵完全二叉树，仅仅“浪费”了一个下标为 0 的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间。

可以看下面这个例子：

<img src="../Resources1/37.jpg" alt="Figure" style="zoom:40%;" />

所以，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要额外的左右子节点的指针。

这也是为什么完全二叉树单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠在左边的原因.

当后面讲到堆和堆排序的时候，就会发现，**堆其实就是一种完全二叉树，最常用的存储方式就是数组.**

## 二叉树的遍历



二叉树的遍历是二叉树中非常重要的操作，也是非常常见的面试题 。

面试问题：如何将所有节点都遍历打印出来？

### 遍历方法

**前序遍历、中序遍历、后序遍历. **

**其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序.**



		> - **前序遍历：对树中任意节点，先打印这个节点，然后再打印它的左子树，最后打印它的右子树；**
		>
		>   
		>
		> - **中序遍历：对树中任意节点，先打印它的左子树，然后打印它本身，最后打印它的右子树；**
		>
		>   
		>
		> - **后序遍历，对树中任意节点，先打印它的左子树，然后打印它的右子树，最后打印这个节点本身.**

<img src="../Resources1/38.jpg" alt="Figure" style="zoom:40%;" />



**实际上，二叉树的前、中、后序遍历就是一个递归过程.**比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树.

### 代码实现

`写递归代码的关键，就是看能不能写出递推公式，而写递归公式的关键就是，如果要解决问题 A，就假设子问题 B、C 已经解决，然后再来看如何利用B、C来解决A.`

- 先把前、中、后序遍历的递推公式都写出来

  ```java
  // 前序遍历的递推公式：
  preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)
  
  // 中序遍历的递推公式：
  inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)
  
  // 后序遍历的递推公式：
  postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r
  ```

- 代码

  ```java
  
  void preOrder(Node* root) {
    if (root == null) return;
    print root // 此处为伪代码，表示打印root节点
    preOrder(root->left);
    preOrder(root->right);
  }
  
  void inOrder(Node* root) {
    if (root == null) return;
    inOrder(root->left);
    print root // 此处为伪代码，表示打印root节点
    inOrder(root->right);
  }
  
  void postOrder(Node* root) {
    if (root == null) return;
    postOrder(root->left);
    postOrder(root->right);
    print root // 此处为伪代码，表示打印root节点
  }
  ```

### 时间复杂度分析

从前面画的前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说二叉树遍历的时间复杂度是 $O(n)$。



