# 递归

## Outline

[toc]

## 导读

递归是一种应用非常广泛的算法（或者编程技巧）。

之后要讲的很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等等。

所以，搞懂递归非常重要，否则，后面复杂一些的数据结构和算法学起来就会比较吃力。

- 例子：

  周末带着女朋友去电影院看电影，女朋友问你，咱们现在坐在第几排啊？电影院里面太黑了，看不清，没法数，现在怎么办？这个时候，递归就开始排上用场了。于是就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。

  这就是一个非常标准的递归求解问题的分解过程，**去的过程叫“递”，回来的过程叫“归”**。基本上，所有的递归问题都可以用递推公式来表示。刚刚这个生活中的例子，用递推公式将它表示出来就是这样的：

  ```java
  f(n) = f(n-1) + 1	其中, f(1) = 1
  ```

  f(n) 表示你想知道自己在哪一排，f(n-1) 表示前面一排所在的排数，f(1)=1 表示第一排的人知道自己在第一排。有了这个递推公式，就可以很轻松地将它改为递归代码，如下：

  ```java
  int f(int n) {
    if (n == 1) return 1;
    return f(n-1) + 1;
  }
  ```

  

## 递归需要满足的三个条件

### **1. 一个问题的解可以分解为几个子问题的解**

何为子问题？子问题就是数据规模更小的问题。比如，前面讲的电影院的例子，你要知道，“自

己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。

### 2. **这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样**

比如电影院那个例子，你求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路，是一模一样的。

### 3. **存在递归终止条件**

把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。

还是电影院的例子，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是 f(1)=1，这就是递归的终止条件。

## 编写递归代码

- **步骤**：

  **<font color="red">写出递推公式,找到终止条件</font>，将递推公式转化为代码。**

- 例子：

  假如这里有 n 个台阶，每次可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？

  如果有 7 个台阶，可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？

  ```java
  f(n) = f(n-1)+f(n-2)
      
  - 递归终止条件 :
  	f(1) = 1
      f(2) = 2
    
  ```

  - 终止条件分析：

    f(1) = 1	所以 f(1)=1。这个递归终止条件足够吗？可以用 n=2，n=3 这样比较小的数试验一下。

    n=2 时，f(2)=f(1)+f(0)。如果递归终止条件只有一个 f(1)=1，那 f(2) 就无法求解了。所以除了 f(1)=1 这一个递归终止条件外，还要有 f(0)=1，表示走 0 个台阶有一种走法，不过这样子看起来就不符合正常的逻辑思维了。

    所以，可以把 f(2)=2 作为一种终止条件，表示走 2 个台阶，有两种走法，一步走完或者分两步来走。

  - 转换成 代码：

  ```java
  int f(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    return f(n-1) + f(n-2);
  }
  ```

  写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。

## 递归代码正确的思维方式

刚讲的电影院的例子，递归调用只有一个分支，也就是说“一个问题只需要分解为一个子问题”。所以，很容易能够想清楚“递“和”归”的每一个步骤，写起来、理解起来都不难。

但是，当面对的是一个问题要分解为多个子问题的情况，递归代码就没那么好理解了。像刚刚讲的第二个例子，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。

计算机擅长做重复的事情，所以递归正合它的胃口。而人脑更喜欢平铺直叙的思维方式。当看到递归时，总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。

**对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。**很多时候，理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢？

> 如果一个问题 A 可以分解为若干子问题 B、C、D，可以**假设子问题 B、C、D 已经解决**，在此基础上思考如何解决问题 A。而且，**只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。**
>
> 
>
> 因此，**编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。**

## 递归代码要警惕堆栈溢出

在实际的软件开发中，编写递归代码时，会遇到很多问题，比如堆栈溢出。

而堆栈溢出会造成系统性崩溃，后果会非常严重。为什么递归代码容易造成堆栈溢出呢？又该如何预防堆栈溢出呢？

在“栈”那一节讲过，函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。

比如前面的讲到的电影院的例子，如果将系统栈或者 JVM 堆栈大小设置为 1KB，在求解 f(19999) 时便会出现如下堆栈报错：

```java
Exception in thread "main" java.lang.StackOverflowError
```

### 避免出现堆栈溢出

可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，就不继续往下再递归了，直接返回报错。还是电影院那个例子，可以改造成下面这样子，就可以避免堆栈溢出了。

下面代码是伪代码，为了代码简洁，有些边界条件没有考虑，比如 x<=0。

```java
// 全局变量，表示递归的深度。
int depth = 0;

int f(int n) {
  ++depth；
  if (depth > 1000) throw exception;
  
  if (n == 1) return 1;
  return f(n-1) + 1;
}
```

但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。递归代码要警惕重复计算.

## 递归代码要警惕重复计算

除此之外，使用递归时还会出现重复计算的问题。刚才讲的第二个递归代码的例子，如果把整个递归过程分解一下的话，那就是这样的：

<img src="../Resources/25.jpg" alt="Figure" style="zoom:40%;" />

从图中，可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。

为了避免重复计算，可以通过一个数据结构（比如**散列表**）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。

按照上面的思路，来改造一下刚才的代码：

```java
public int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  // hasSolvedList可以理解成一个Map，key是n，value是f(n)
  if (hasSolvedList.containsKey(n)) {
    return hasSolvedList.get(n);
  }
  
  int ret = f(n-1) + f(n-2);
  hasSolvedList.put(n, ret);
  return ret;
}
```

除了堆栈溢出、重复计算这两个常见的问题。递归代码还有很多别的问题。

在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。

在空间复杂度上，**因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销**，比如前面讲到的电影院递归代码，空间复杂度并不是 O(1)，而是 O(n)。

## 怎么将递归代码改写为非递归代码？

递归有利有弊，**利是递归代码的表达力很强，写起来非常简洁**；而**弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题**。所以，在开发过程中，要根据实际情况来选择是否需要用递归的方式来实现。

那是否可以把递归代码改写为非递归代码呢？ 抛开场景，将公式改写为非递归代码：

- f(x) =f(x-1)+1 	递归终止条件 ： f(1) = 1

  ```java
  // java code
      
  int f(int n) {
    int ret = 1;
    for (int i = 2; i <= n; ++i) {
      ret = ret + 1;
    }
    return ret;
  }
  ```

  

- f(n) = f(n-1)+f(n-2)
      递归终止条件 :
  f(1) = 1
    f(2) = 2

  ```java
  // java code
  
  int f(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    
    int ret = 0;
    int pre = 2;
    int prepre = 1;
    for (int i = 3; i <= n; ++i) {
      ret = pre + prepre;
      prepre = pre;
      pre = ret;
    }
    return ret;
  }
  ```

  从上面代码可以看出：所有的递归代码都可以改为这种**迭代循环的非递归写法**.

  因为递归本身就是借助栈来实现的，只不过使用的栈是系统或者虚拟机本身提供的，人们没有感知罢了。

  如果自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。

## 思考题 (暂时可略)

> 给定一个用户 ID，如何查找这个用户的“最终推荐人”？

```java
long findRootReferrerId(long actorId) {
  Long referrerId = select referrer_id from [table] where actor_id = actorId;
  if (referrerId == null) return actorId;
  return findRootReferrerId(referrerId);
}
```

是不是非常简洁？用三行代码就能搞定了，不过在实际项目中，上面的代码并不能工作，为什么呢？这里面有两个问题。

第一，如果递归很深，可能会有堆栈溢出的问题。

第二，如果数据库里存在脏数据，我们还需要处理由此产生的无限递归问题。比如 demo 环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果 A 的推荐人是 B，B 的推荐人是 C，C 的推荐人是 A，这样就会发生死循环。

第一个问题，前面已经解答过了，可以用限制递归深度来解决。第二个问题，也可以用限制递归深度来解决。不过，还有一个更高级的处理方法，就是自动检测 A-B-C-A 这种“环”的存在。如何来检测环的存在呢？这个我暂时不细说，你可以自己思考下，后面的章节我们还会讲。





*`@ 笔记时间 ：2020-8-26 FROM	极客时间 《算法啊与数据结构之美》 王争  专栏`* 