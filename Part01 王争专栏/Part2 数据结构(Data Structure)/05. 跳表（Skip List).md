# 跳表 （Skip List）

[toc]

## 定义

跳表（Skip List）是一种随机化的数据， 由 William Pugh 在论文《Skip lists: a probabilistic alternative to balanced trees》中提出， 跳表以有序的方式在层次化的链表中保存元素。

它是各方面性能都比较优秀的 **动态数据结构**，可以支持快速地插入、删除、查找操作，写起来也不复杂，甚至可以替代 **红黑树 （Red-Black Tree)(平衡树）**.

<img src="../Resources1/08.jpg" alt="Figure" style="zoom:50%;" />

成分说明：

- 表头（head）：负责维护跳跃表的节点指针。
  
- 跳跃表节点：保存着元素值，以及多个层。

- 层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。

- 表尾：全部由 NULL 组成，表示跳跃表的末尾。


## 理解 跳表 

对于 **单链表**，即便链表中存储的数据是有序的，如果要在其中查找某个苏剧，也只能从头到尾遍历链表。这样查询效率会很低，时间复杂度会很高，是 $O(n)$.

<img src="../Resources1/04.jpg" alt="Figure" style="zoom:50%;" />

### 为提高效率，对链表建立一级"索引"

每两个节点提取一个节点到上一级，把抽出来的那一级叫做 **索引** 或 **索引层**。

<img src="../Resources1/05.jpg" alt="Figure" style="zoom:50%;" />

其中，down 表示 down 指针，指向下一级结点。

如果现在要查找 16 节点，可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，发现下一个节点是 17，那要查找的节点 16 肯定就在这两个节点之间。

然后，通过索引层节点的 down 指针，下降到原始链表这一层，继续遍历。

这时，只需要再遍历 2 个节点，就可以找到值等于 16 的这个节点。

这样，原来要查找 16，需要遍历 10 个节点，现在只需要遍历 7 个节点。

由此可以看出，**加来一层索引之后，查找一个节点需要遍历的节点个数减少了，也就是查找效率提高了。**

### 建立二级索引

在第一级索引的基础之上，每两个节点就抽出一个节点到第二级索引。

<img src="../Resources1/06.jpg" alt="Figure" style="zoom:50%;" />

现在，查找 16 节点，只需要遍历 6 个节点（1,7,13, down 13, down 13, 16), 需要遍历的节点数量又减少了。

### 感受多级索引提升的查询效率

包含 64 个节点的链表，并按照在之前索引的基础上，每两个节点就抽出一个节点到上级节点方法，建立了五级索引.

<img src="../Resources1/07.jpg" alt="Figure" style="zoom:50%;" />

现在，查找 62 节点：

- 没有索引 ： 遍历 62 个节点
- 有索引   ： 遍历 11 个节点。

## 分析 跳表

### 时间复杂度分析

如果链表中有 n 个节点，会有多少级索引？（每两个节点会抽出一个节点作为上一级索引的节点）

  - 一级索引节点个数： $n/2$
  - 二级索引节点个数： $n/4$
  - 三级索引节点个数： $n/8$
  - 依此类推....

 **第 k 级索引的结点个数是第 k - 1 级索引的节点个数的 $1/2$，那第 k 级索引节点的个数就是 $n/2^k$ </font>**

<font color="orange">假设索引有 h 级，最高的索引有 2 个节点，则 $n/2^h=2$,从而得到 $h = log_2{n-1}$.如果包含原始链表这一层，整个跳表的高度就是 $log_2{n}$ .所以，在跳表中查询某个数据的时候，如果每一层都要遍历 m 个节点，那在跳表中查询一个数据的时间复杂度就是 $O(m*log\ n)$.</font>

按照前面这种索引结构，每一级索引都最多只需要遍历 3个节点，也就是说 m = 3，但为什么是 3 呢？


假设要查找的数据是 x，在第 k 级索引中，遍历到 y 节点后，发现 x 大于 y，但 小于 后面的节点 z，所以通过 y 的 down 指针，从第 k 级索引下降到第 k - 1 级索引。在 k - 1 级索引中，y 和 z 之间只有 3 个节点**（包含 y 和 z）**，所以，在 k - 1 级索引中最多只需要遍历 3 个节点，依次类推，每一级索引都最多只需要遍历 3 个节点。

<img src="../Resources1/09.jpg" alt="Figure" style="zoom:50%;" />

通过上面的分析，m = 3, 所以跳表中查询任意数据的时间复杂度是 $O(logn)$.

> 这个是查找时间复杂度跟二分查找是一样的，换句话说，这其实是基于单链表实现了二分查找。根据空间换时间的设计思路，这样做会使用掉很多空间。

### 空间复杂度分析

跳变需要存储多级索引，跟定要消耗更多的空间，那到底需要消耗多少额外空间呢？

- 假设原始链表大小为 n, 第一级索引大约有 $n/2$ 个节点，第二级索引大约有 $n/4$ 个节点，依次类推，每上升一级就减少一半，直到剩下 2 个节点，这其实是个等比数列。

<img src="../Resources1/10.jpg" alt="Figure" style="zoom:50%;" />

- 节点总和
  
  $n/2+n/4+n/8...+8+4+2=n-2$

- 空间复杂度
  
  $O(n)$

也就是说，如果将包含 n 个节点的单链表构造成跳表，需要额外在用接近 n 个节点的存储空间。

那能否降低索引占用的内存空间？

前面的索引结构是每两个节点抽一个节点到上级索引，如果每三个或五个节点抽一个节点到上级索引呢？

<img src="../Resources1/11.jpg" alt="Figure" style="zoom:50%;" />

- 一级索引：$n/3$

- 二级索引：$n/9$

- 依此类推，每往上一级，索引节点数都除以 3.

为了方便，假设最高一级的索引节点个数是 1,写下每级索引的结点个数：

<img src="../Resources1/12.jpg" alt="Figure" style="zoom:50%;" />

- 通过等比数列求和公式，总的索引节点个数

  $n/3+n/9+n/27+...+9+3+1=n/2$.

- 空间复杂度 
  
  $O(n)$

但是比上面每两个结点抽一个节点的索引构造方法，减少了一半的索引节点存储空间。


> 实际上，在软件开发中，不必太在意索引占用的额外空间。
> 
> 在讲数据结构和算法时，习惯性地把要处理的数据看成整数，但在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引节点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引节点大很多时，那索引占用的额外空间就可以忽略了。

## 高效的动态 插入 和 删除

跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 $O(log\ n)$.

### 插入 操作

#### 单链表

一旦定位好要插入的位置，插入节点的时间复杂度是很低的，就是 $O(1).$ 

但是，为了保证原始链表中数据的有序性，需要先遍历每个节点，找到插入的位置，这个查找操作就会比较耗时。

#### 跳表

查找某个节点的时间复杂度 $O(log\ n)$,所以这里查找某个数据该插入的位置，方法也是类似的，时间复杂度也是 $O(log\ n$.

<img src="../Resources1/13.jpg" alt="Figure" style="zoom:50%;" />



### 删除 操作

如果要删除的节点在索引也有出现，则既要删除原链表中的节点，也要删除索引中的。

因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果是双向链表，就不需要考虑这个问题了。

## 索引状态更新

当不停地往跳表中插入数据时，如果不断地更新索引，就有可能出现某 2 个索引节点之间数据非常多的情况。

极端情况下，跳表会退化成单链表。

<img src="../Resources1/14.jpg" alt="Figure" style="zoom:50%;" />

所以，需要某种手段来维护索引与原始链表大小之间的平衡，即，如果链表中节点多了，索引节点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。

像红黑树、AVL树这样的平衡二叉树，通过左右旋的方式保持左右子树的大小平衡。

跳表通过随机函数来维护前面提到的`平衡性`。

当往跳表中插入数据时，可以选择同时将这个数据插入到部分索引层中，但如何选择索引层呢？

解决方法是，通过一个随机函数，来决定这个节点插入到哪几级索引中，比如随机函数生成了值 K，那就将这个节点添加到第一级到第 K 级这 K 级索引中。

<img src="../Resources1/15.jpg" alt="Figure" style="zoom:50%;" />

随即函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。（随即函数参见之后代码或 Redis 中关于有序集合的跳表实现）



## 思考题

1. 如果每三个或者五个结点提取一个结点作为上级索引，对应的在跳表中查询数据的时间复杂度是多少呢？

   如果每三个或者五个节点提取一个节点作为上级索引，那么对应的查询数据时间复杂度，应该也还是 O(logn)。

   假设每 5 个节点提取，那么最高一层有 5 个节点，而跳表高度为 $log_5n$，每层最多需要查找 6 个节点(包括后面一个节点)，即 O(mlogn) 中的 m = 6，最终，时间复杂度为 O(logn)。

   空间复杂度也还是 O(logn)，虽然省去了一部分索引节点，但是似乎意义不大。

2.  Redis 为什么会选择用跳表来实现有序集合呢？

   redis有序集合是跳跃表实现的，直接这么说有失偏驳，他是复合数据结构，准确说应该是由一个双hashmap构成的字典和跳跃表实现的

   Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。不过散列表我们后面才会讲到，所以我们现在暂且忽略这部分。如果你去查看 Redis 的开发手册，就会发现，Redis 中的有序集合支持的核心操作主要有下面这几个：

   - 插入一个数据；
   - 删除一个数据；
   - 查找一个数据；
   - 按照区间查找数据（比如查找值在[100, 356]之间的数据）；
   - 迭代输出有序序列。

   其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。

   对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。

   当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。

   不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。

*`@ 笔记时间 ：2020-11-03 FROM	极客时间 《算法啊与数据结构之美》 王争  专栏`* 