# 散列表 II (Hash Table)

[toc]

## 如何设计散列函数

散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能.

### 好的散列函数的标准:

  1. **散列函数的设计不能太复杂**:

     过于复杂的散列函数，势必会消耗很多计算时间，也就间接地影响到散列表的性能
  
  2. **散列函数生成的值要尽可能随机并且均匀分布**:

     尽可能的随机并且均匀分布，才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况.

### 常用的、简单的散列函数的设计方法举例

- 实际工作中，需要综合考虑各种因素，包括关键字的长度、特点、分布、散列表大小。

- 举例方法1：数据分析法
  
    上节学生运动会的例子，通过分析参赛编号的特征，把编号中的后两位作为散列值。

    还可以用类似的散列函数处理手机号码，因为手机号码前几位重负的可能性很大，但后面的几位就比较随机，可以去手机号的后四位作为散列值，这种散列函数的设计方法。

- 举例方法2：求余、取模法

    这个列子，就是上一节开篇的思考题，如何如何实现 Word 拼写检查功能.

    将单词中的每个单词的 `ASCII 码 的值` `进位` 相加，然后再跟散列表的大小求余、取模，作为散列值。

    例如，英文单词 `nice`，转换出来的散列值就是
    
    ```java
    hash("nice")=(("n"-"a")*26*26*26 + ("i"-"a")*26*26+("c"-"a")*26+("e"-"a"))/78978
    ```
- 其他设计方法：
  
  - 直接寻址法
  
  - 平方取中法
  
  - 折叠法
  
  - 随机数法

## 装载因子过大了怎么办?

   
`装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大.不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢.`

### 对于静态散列表
  
对于没有频繁插入和删除的静态散列表来说，很容易根据数据的特点、分布等，设计出完美的、极少冲突的散列函数，因为毕竟之前数据都是已知的。

### 对于动态散列表
  
对于动态散列表来说，数据集合是频繁变动的，事先无法预估将要加入的数据个数，所以无法事先申请一个足够大的散列表，随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受.

当装载因子过大时，可以对散列表进行 `动态扩容`，重新申请一个更大的散列表，将数据搬移到这个新散列表中。

## 散列表动态扩容

假设每次扩容都申请一个原来散列表大小两倍的空间，如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4.

`针对数组的扩容，数据搬移操作比较简单。但是，针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，所以需要通过散列函数重新计算每个数据的存储位置.`

- 例子：

<img src="../Resources1/21.jpg" alt="Figure" style="zoom:50%;" />

在原来的散列表中，21 这个元素原来存储在下标为 0 的位置，搬移到新的散列表中，存储在下标为 7 的位置。

## 时间复杂度分析

### 插入操作

- 最好情况：$O(1)$

  插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 $O(1)$.

- 最坏情况：$O(n)$
  
  散列表装载因子过高，启动扩容，需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 $O(n)$.

- 平均情况：$O(1)$

  用摊还分析法、均摊情况下，时间复杂度接近最好情况，就是 $O(1)$.

### 删除操作

对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲控件会越来越多.

如果对空间消耗非常敏感，可以在装载因子小于某个值后，启动动态缩容.

如果更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了.


### 装载因子阙值大小的选择

> 当散列表的装载因子超过某个阙值时，就需要进行扩容。装载因子阙值需要选择得当，如果太大，会导致冲突过多；如果太小，会导致内存浪费严重.

- 装载因子阙值的设置需要权衡时间、空间复杂度。
  
- 如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阙值；

- 相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于1.

## 避免低效扩容

在大部分情况下，动态扩容的散列表插入一个数据都很快，但是在特殊情况下，当装载因子已经达到阙值，需要先进行扩容，再插入数据。这个时候，插入数据会变很慢，甚会无法接受.

举一个极端的例子：

如果散列表当前大小为 1GB,要想扩容为原来的两倍大小，那就需要对 1GB 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表，听起来非常耗时。

如果业务代码直接服务于用户，尽管大部分情况下，插入一个数据的操作都很快，但是，极个别非常慢的插入操作，也会让用户崩溃.这时，"一次性"扩容的机制就不合适了.

### 解决一次性扩容耗时过多的情况

为了解决依次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成.
  
1. 当装载因子触达阙值之后，只需申请新空间，但并不将老的数据搬移到新散列表中.
   
2. 当有新数据要插入时，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表中.
   
3. 每次插入一个数据到散列表中，都重复上面的过程.
   
4. 经过多次插入操作后，老的散列表中的数据就一点一点全部搬移到新散列表中了.
   
这样没有了集中的一次性数据搬移，插入操作就都变得很快了.

<img src="../Resources1/22.jpg" alt="Figure" style="zoom:50%;" />


### 搬移期间的查询操作

对于查询操作，为了兼容新、老散列表中的数据，先从新散列表中查找，如果没有找到，再去老的散列表中查找。

### 时间复杂度分析

通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 $O(1)$.

## 冲突解决方法：开发寻址法 VS 链表法

### 1. 开放寻址法

#### 优点

开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快速查询速度。而且，这种方法实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没有那么容易。

#### 缺点

开发寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大，这也导致了比链表法更加浪费内存空间。

#### 总结

`当数据量比较小、装载因子小的时候，适合采用开发寻址法。`

这也是 Java 中的 ThreadLocalMap 使用开放寻址法解决散列冲突的原因。

### 2. 链表法

#### 优点

1. 链表法对内存的利用率比开放寻址法要高.
  
   因为链表节点可以在需要的时候再创建，并不需要像开发寻址法那样事先申请好,这一点也是链表优于数组的地方。

2. 链表法对大装载因子的容忍度更高.

    链表法比起开发寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。
  
    但对于链表法来说，只要散列函数的值随机均匀，即便装载因子装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多.

#### 缺点

- 消耗内存

  因为链表要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。而且，因为链表中的节点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好，这方面对于执行效率也有一定的影响.

  当然，如果存储的是大对象，也就是说要存储的对象的大小远远大于一个指针的大小（4个字节或者8个字节），那链表中指针的内存消耗在大对象面前就可以忽略了.


#### 改造链表法

实际上，对链表法稍加改造，可以实现一个更加高效的散列表。

将链表法中的链表改造为其他高效的动态数据结构，比如 跳表、红黑树。

这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 $O(logn)$，这样也就有效避免了散列碰撞攻击。


<img src="../Resources1/23.jpg" alt="Figure" style="zoom:50%;" />

### 总结

`基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开发寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表.`

## 工业级散列表举例分析

举例分析 Java 中的 HashMap 这样一个工业级散列表，是如何实现的.

### 1. 初始大小

HashMap 默认的初始大小是 16，当然这个默认值是可以设置的，如果事先指定大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能.

### 2. 装载因子和动态扩容

最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75 * capacity(capacity 表示散列表的容量)的时候，就会启动扩容，每次扩容队都会扩容为原来的两倍大小.

### 3. 散列冲突解决方法

HashMap 底层采用链表法来解决冲突.即使负载因子和散列函数设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能.

于是，再 JDK 1.8 版本中，为了对 HashMap 做进一步优化，引入红黑树.

而当链表长度太长（默认超过 8）时，链表就转换为红黑树。可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。

`当红黑树节点少于 8 个的时候，又会将红黑树转化为链表.`

因为在数据较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显.

### 4. 散列函数

散列函数的设计并不复杂，追求的是简单高效、分布均匀.

```Java
int hash(Object key) {
    int h = key.hashCode()；
    return (h ^ (h >>> 16)) & (capicity -1); //capicity表示散列表的大小
}
```

- 其中，hashCode() 返回的是 Java 对象的 hash code. 比如 String 类型的对象的 hashCode() 就是下面这样：

```Java
public int hashCode() {
  int var1 = this.hash;
  if(var1 == 0 && this.value.length > 0) {
    char[] var2 = this.value;
    for(int var3 = 0; var3 < this.value.length; ++var3) {
      var1 = 31 * var1 + var2[var3];
    }
    this.hash = var1;
  }
  return var1;
}
```

## 如何设计一个工业级的散列函数？
  
   如果这是一道面试题或者是摆在面前的实际开发问题，会从哪几个方面思考呢？

   - 结合已经学过的散列知识，应该有这样几点：

     - **支持快速地查询、插入、删除操作**；
  
     - 内存占用合理，不能浪费过多的内存空间；
   
     - **性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况**.
   
   - **如何实现这这样一个散列表**：
     
     - 设计一个合适的散列函数；
     
     - 定义装载因子阙值，并且设计动态扩容策略；
     
     - 选择合适的散列冲突解决方法.
  
具体如何选择散列函数、装载因子、动态扩容策略，还有散列冲突的解决办法，还要结合具体的业务场景、具体的业务数据来具体分析。

## 思考

在你熟悉的编程语言中，哪些数据类型底层是基于散列表实现的？散列函数是如何设计的？散列冲突是通过哪种方法解决的？是否支持动态扩容呢？

### Java

JDK hashMap源码，hash表中数组位置的计算分两步：

1. 计算hash值：

  ```Java
  hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
  }
  ```
  这一步有一种说法，叫它扰动函数，为什么要右移16位再与本身异或呢？

   - 首先hashCode()返回值int最高是32位，如果直接拿hashCode()返回值作为下标，大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般是很难出现碰撞的。问题是一个40亿长度的数组，内存是放不下的。

   - 所以，用自己的高半区和低半区做异或，混合原始哈希码的高位和低位，关键是以此来加大低位的随机性。为后续计算index截取低位，保证低位的随机性。

   - 这样设计保证了对象的hashCode的32位值只要有一位发生改变，整个hash()返回值就会改变，高位的变化会反应到低位里，保证了hash值的随机性。

2. 在插入或查找的时候，计算Key被映射到桶的位置：
  
  ```Java
  int index = hash(key) & (capacity - 1);
  ```
  hash()扰动函数计算的值和hash表当前的容量减一，做按位与运算。

 - 为什么要减一，又为什么要按位与运算？

    因为 `A % B = A & (B - 1)`，当B是2的指数时，等式成立。

    本质上是使用了「除留余数法」，保证了index的位置分布均匀。

 - 为什么HashMap的数组长度必须是2的整次幂？

    数组长度是2的整次幂时，（数组长度-1）正好相当于一个**低位掩码**，**与** 操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。

    以初始长度16为例，16-1=15。2 进制表示是00000000 00000000 00001111。
    
    **与** 操作的结果就是截取了最低的四位值, 也就相当于取模操作。


    *`@ 笔记时间 ：2020-11-08 FROM	极客时间 《算法啊与数据结构之美》 王争  专栏`* 