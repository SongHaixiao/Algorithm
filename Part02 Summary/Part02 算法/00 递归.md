# 递归算法

[toc]

### 理解递归

周末带着女朋友去电影院看电影，女朋友问你，咱们现在坐在第几排啊？电影院里面太黑了，看不清，没法数，现在怎么办？

这个时候，递归就开始排上用场了。于是就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。

这就是一个非常标准的递归求解问题的分解过程，**去的过程叫“递”，回来的过程叫“归”**。

基本上，所有的递归问题都可以用递推公式来表示。刚刚这个生活中的例子，用递推公式将它表示出来就是这样的：

```java
f(n)=f(n-1)+1, 其中 f(1)=1
```

说明：

- f(n) ：想知道自己在哪一排；
- f(n-1) ：表示前面一排所在的排数；
- f(1) = 1 ：表示第一排的人知道自己在第一排.

有了这个递推公式，就可以很轻松地将它改为递归代码，如下：

```java
int f(int n) {
    if (n == 1) return 1;
    return f(n - 1) + 1;
}
```

### 满足递归的三个条件

>**1. 一个问题的解可以分解为几个子问题的解；**
>
>**2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样；**
>
>**3. 存在递归终止条件**

### 编写递归代码

#### 步骤

> **1. 写出递推公式；**
>
> **2. 找到终止条件；**
>
> **3. 将递归公式转化为代码。**

#### 举例

**问题：假如这里有 n 个台阶，每次可以跨 1 个台阶 或者 2 个台阶，请问这 n 个台阶有多少种走法？**

如果有 7 个 台阶，可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法很多，那如何用编程求得总共有多少种走法呢？

```java
f（n）= f（n-1）+ f(n-2)
    
- 递归终止条件：
	f(1) = 1
    f(2) = 2
```

- 终止条件分析：

  f(1) = 1 : 当 只剩下一个台阶时，只能有一种走法。

  但只有这个终止条件够吗？

  可以用 n = 2, n = 3这样比较小数体验一下：

  当 n = 2 时，f(2) = f(1) + f(0)，如果递归终止条件只有一个 f(1) = 1, 那么 f(2) 就无法求解。

  所以，除了 f(1) = 1,这一个递归终止条件外，还要有 f(0) = 1,表示走 0 个台阶有一种走法，不过这样看起来就不符合正常的逻辑了。

  所以，可以把 f(2) = 2 作为一种终止条件，表示走 2 个台阶，有两种走法，一步走完或者分两步走完。

- 代码：

  ```java
  int f(int n){
      if (n == 1) return 1;
      if (n == 2) return 2;
      return f(n - 1) + f(n - 2);
  }
  ```

- 总结：

  **写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最好将递推公式和终止条件翻译成代码。**

### 递归代码正确的思维方式

#### 错误想法

对于递归代码，试图想清楚整个递归过程的做法，实际上是进入了一个思维误区.

#### 正确想法

如果一个问题 A 可以解决为若干子问题 B、C、D已经解决，在此基础上思考如何解决问题 A.而且，只需要思考问题 A 与 子问题 B、C、D 两层之间的关系即可，不需要一层一层地往下思考子问题与子子问题，子子问题与子子子问题之间的关系.屏蔽掉递归细节，这样子理解起来就简单很多了.

> **因此，编写递归代码的关键是，只要遇到递归，就把它抽象成一个递推公式，不用想一层层地调用关系，不要视图用人脑去分解递归的每个步骤。**

### 递归代码要注意的地方

#### 1. 避免堆栈溢出

使用递归，会造成堆栈溢出。

堆栈溢出会造成系统性崩溃，后果会非常严重。为什么递归代码容易造成堆栈溢出呢？又该如何预防堆栈溢出呢？

在“栈”那一节讲过，函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。

比如前面的讲到的电影院的例子，如果将系统栈或者 JVM 堆栈大小设置为 1KB，在求解 f(19999) 时便会出现如下堆栈报错：

```java
Exception in thread "main" java.lang.StackOverflowError
```

可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，就不继续往下再递归了，直接返回报错。还是电影院那个例子，可以改造成下面这样子，就可以避免堆栈溢出了。

下面代码是伪代码，为了代码简洁，有些边界条件没有考虑，比如 x<=0

```java
// 全局变量，表示递归深度
int depth = 0;

int f(int n){
    ++depth;
    if (depth > 1000) throw exception;
    
    if (n == 1) return 1;
    
    return f(n - 1) + 1;
}
```

但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。

所以，**如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。**

#### 2. 警惕重复计算

使用递归，会出现重复计算的问题。

之前讲的第二个递归代码的例子，如果把整个递归过程分解一下，就是这样的：

<img src="Resources/00.jpg" style="zoom:50%;" />

从图中，科院直观地看到，想要计算 f(5), 就需要计算 f(4) 和 f(3)，而计算 f(4) 还要计算 f(3), 因此，f(3) 就被计算了很多次，这就是重复计算问题.

为了避免重复计算，可以通过一个数据结构（如，**散列表**) 来保存已经求解过的 **f(k)**.

当递归调用的 **f(k)** 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就可以避免刚讲的问题.

按照上面的思路，来改造一下刚才的代码：

```java
public int f(int n){
    if (n == 1) return 1;
    if (n == 2) return 2;
    
    // hasSolvedList 可以理解成一个 Map，key 是 n, value 是 f(n)
    if(hasSolvedList.containsKey(n)){
        return hasSolvedList.get(n);
    }
    
    int ret = f(n - 1) + f(n - 2);
    hasSolvedList.put(n,ret);
    return ret;
}
```

#### 3. 注意时间和空间成本

在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会聚积成一个客观的时间成本。

在空间复杂度上，**因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。**比如，前面讲到电影院递归代码，空间复杂度并不是 $O(1)$,而是 $O(n)$.

### 递归的利弊

>**利：表达能力强，写起来非常简洁**；
>
>**弊：空间复杂度高、有堆栈溢出的风险、存在重复计算、过多地函数调用会耗时较多等问题.**

所以，在开发过程中，要根据实际情况来选择是否需要用递归的方式来实现.

### 将递归代码改写为非递归代码

抛开场景将递归代码改写为非递归代码, 即将公式改写为非递归代码：

- $f(x)=f(x-1)+1$ ，终止条件为 $f(1) = 1$

  ```java
  //java code
  int f(n){
      int ret = 1;
      for(int i = 2; i <= n; ++i){
          ret = ret + 1;
      }
      return ret;
  }
  ```

- $f(n)=f(n-1)+f(n-2)$,终止条件为 $f(1) = 1,f(2) = 2$

  ```java
  // java code
  int f(int n){
      if (n == 1) return 1;
      if (n == 2) return 2;
      
      int ret = 0;
      int pre = 2;
      int prepre = 1;
       
      for(int i = 3; i <= n; ++i){
          ret = pre + prepre;
          prepre = pre;
          pre = ret;
      }
      
      return ret;
  }
  ```

  从以上代码可以看出：所有的递归代码都可以改为这种 **迭代循环的非递归写法.**

  因为递归本身就是借助栈来实现的，只不过使用的栈是系统或者虚拟机本身提供的，人们没有感知罢了。

  如果自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。

  但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。

  `@ 二次总结 ：2020-11-23 	FROM	极客时间 《算法与数据结构之美》 王争  专栏` 