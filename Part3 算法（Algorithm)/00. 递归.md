# 递归

递归是一种应用非常广泛的算法（或者编程技巧）。

之后要讲的很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等等。

所以，搞懂递归非常重要，否则，后面复杂一些的数据结构和算法学起来就会比较吃力。

- 例子：

  周末带着女朋友去电影院看电影，女朋友问你，咱们现在坐在第几排啊？电影院里面太黑了，看不清，没法数，现在怎么办？这个时候，递归就开始排上用场了。于是就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。

  这就是一个非常标准的递归求解问题的分解过程，**去的过程叫“递”，回来的过程叫“归”**。基本上，所有的递归问题都可以用递推公式来表示。刚刚这个生活中的例子，用递推公式将它表示出来就是这样的：

  ```java
  f(n) = f(n-1) + 1	其中, f(1) = 1
  ```

  f(n) 表示你想知道自己在哪一排，f(n-1) 表示前面一排所在的排数，f(1)=1 表示第一排的人知道自己在第一排。有了这个递推公式，就可以很轻松地将它改为递归代码，如下：

  ```java
  int f(int n) {
    if (n == 1) return 1;
    return f(n-1) + 1;
  }
  ```

  

## 递归需要满足的三个条件

1. **一个问题的解可以分解为几个子问题的解**

   何为子问题？子问题就是数据规模更小的问题。比如，前面讲的电影院的例子，你要知道，“自

   己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。

2. **这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样**

   比如电影院那个例子，你求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路，是一模一样的。

3. **存在递归终止条件**

   把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。

   还是电影院的例子，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是 f(1)=1，这就是递归的终止条件。

## 编写递归代码

- **步骤**：
  - **<font color="red">写出递推公式,找到终止条件</font>**
  - **将递推公式转化为代码**

- 例子：

  假如这里有 n 个台阶，每次可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？

  如果有 7 个台阶，可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？

  ```java
  f(n) = f(n-1)+f(n-2)
      
  - 递归终止条件 :
  	f(1) = 1
      f(2) = 2
    
  ```

  - 终止条件分析：

    f(1) = 1	所以 f(1)=1。这个递归终止条件足够吗？可以用 n=2，n=3 这样比较小的数试验一下。

    n=2 时，f(2)=f(1)+f(0)。如果递归终止条件只有一个 f(1)=1，那 f(2) 就无法求解了。所以除了 f(1)=1 这一个递归终止条件外，还要有 f(0)=1，表示走 0 个台阶有一种走法，不过这样子看起来就不符合正常的逻辑思维了。

    所以，可以把 f(2)=2 作为一种终止条件，表示走 2 个台阶，有两种走法，一步走完或者分两步来走。

  - 转换成 代码：

  ```java
  int f(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    return f(n-1) + f(n-2);
  }
  ```

  写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。

## 递归代码正确的思维方式

刚讲的电影院的例子，递归调用只有一个分支，也就是说“一个问题只需要分解为一个子问题”。所以，很容易能够想清楚“递“和”归”的每一个步骤，写起来、理解起来都不难。

但是，当面对的是一个问题要分解为多个子问题的情况，递归代码就没那么好理解了。像刚刚讲的第二个例子，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。

计算机擅长做重复的事情，所以递归正合它的胃口。而人脑更喜欢平铺直叙的思维方式。当看到递归时，总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。

**对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。**很多时候，理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢？

> 如果一个问题 A 可以分解为若干子问题 B、C、D，可以**假设子问题 B、C、D 已经解决**，在此基础上思考如何解决问题 A。而且，**只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。**
>
> 
>
> 因此，**编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。**

## 递归代码要警惕堆栈溢出

在实际的软件开发中，编写递归代码时，会遇到很多问题，比如堆栈溢出。

而堆栈溢出会造成系统性崩溃，后果会非常严重。为什么递归代码容易造成堆栈溢出呢？又该如何预防堆栈溢出呢？

在“栈”那一节讲过，函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。

比如前面的讲到的电影院的例子，如果将系统栈或者 JVM 堆栈大小设置为 1KB，在求解 f(19999) 时便会出现如下堆栈报错：

```java
Exception in thread "main" java.lang.StackOverflowError
```

### 避免出现堆栈溢出

可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，就不继续往下再递归了，直接返回报错。还是电影院那个例子，可以改造成下面这样子，就可以避免堆栈溢出了。

下面代码是伪代码，为了代码简洁，有些边界条件没有考虑，比如 x<=0。

```java
// 全局变量，表示递归的深度。
int depth = 0;

int f(int n) {
  ++depth；
  if (depth > 1000) throw exception;
  
  if (n == 1) return 1;
  return f(n-1) + 1;
}
```

但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。递归代码要警惕重复计算.

## 递归代码要警惕重复计算

除此之外，使用递归时还会出现重复计算的问题。刚才讲的第二个递归代码的例子，如果把整个递归过程分解一下的话，那就是这样的：

<img src="../Resources/25.jpg" alt="Figure" style="zoom:50%;" />