# 排序算法（上）

## Outline

[toc]

## 导读

- 经典排序算法：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。
- 按复杂度划分：
- $O(n^2)$ : 冒泡排序、插入排序、选择排序.
- $O(nlogn)$ : 快速排序、归并排序.
- $O(n)$ : 桶排序、计数排序、基数排序.

## 如何分析一个排序算法

学习排序算法，除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。

### **<font color="orange">排序算法的执行效率</font>**

#### 1. 最好情况、最坏情况、平均情况时间复杂度

在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。

为什么要区分这三种时间复杂度呢？

第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。

第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，所以要知道排序算法在不同数据下的性能表现。

#### 2. 时间复杂度的系数、常数 、低阶

时间复杂度反映的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。

但是实际的软件开发中，排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，就要把系数、常数、低阶也考虑进来。

#### 3. 比较次数和交换（或移动）次数

基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。

所以，如果在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

### **<font color="orange">排序算法的内存消耗</font>**

算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。

不过，针对排序算法的空间复杂度，还引入了一个新的概念，**原地排序（Sorted in place）**。

**<font color="blue">原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。</font>**

冒泡、插入、选择排序，这三种排序算法，都是原地排序算法。

### **<font color="orange">排序算法的稳定性</font>**

仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，还有一个重要的度量指标，**稳定性**。

**<font color="blue">稳定性是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</font>**

例子：有一组数据 2、9、 3、 4、 8、 3， 按照大小排序之后就是 2、3、3、4、8、9。

这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那就把这种排序算法叫作**稳定的排序算法**；如果前后顺序发生变化，那对应的排序算法就叫作**不稳定的排序算法**。

你可能要问了，两个 3 哪个在前，哪个在后有什么关系啊，稳不稳定又有什么关系呢？为什么要考察排序算法的稳定性呢？

很多数据结构和算法课程，在讲排序的时候，都是用整数来举例，但在真正软件开发中，要排序的往往不是单纯的整数，而是一组对象，需要按照对象的某个 key 来排序。

比如说，现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果现在有 10 万条订单数据，希望按照金额从小到大对订单数据排序。对于金额相同的订单，希望按照下单时间从早到晚有序。

对于这样一个排序需求，怎么来做呢？

最先想到的方法是：先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。

借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，用稳定排序算法，按照订单金额重新排序。两遍排序之后，得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。为什么呢？

**<font color="blue">稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。</font>**

第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。

![Figure](../Resources/03.jpg)

# 冒泡排序 （Bubble Sort）

## 概念

> 冒泡排序只会操作相邻的两个数据。
>
> 每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。
>
> 如果不满足就让它俩互换。
>
> 一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

## 举例说明

将一组数据 ： 4, 5, 6, 3, 2, 1 从 小到大进行排序。

- 第一次冒泡操作的详细过程：

  ![Figure](C:/Users/xxnzj/Documents/GitHub/Algorithm/Resources/04.jpg)

  经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。

- 要想完成所有数据的排序，只要进行 6 次这样的冒泡操作就行了：

  ![Figure](C:/Users/xxnzj/Documents/GitHub/Algorithm/Resources/05.jpg)

## 未优化代码 ：全部遍历

```java
// java code
// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp; 
      }
    }
  }
}
```



## 过程优化

**<font color="blue">当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作</font>。**

例子：下面给出要对 6 个元素进行冒泡排序，但是只需要 4 次冒泡操作就可以了。

![Figure](C:/Users/xxnzj/Documents/GitHub/Algorithm/Resources/06.jpg)

## 优化代码：没有交换（已排好序），提前结束

```java
// java code
// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```

### 分析：

**第一，冒泡排序是原地排序算法吗？**

冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 $O(1)$，是一个原地排序算法。

**第二，冒泡排序是稳定的排序算法吗？**

在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

**第三，冒泡排序的时间复杂度是多少？**

- 最好情况：要排序的数据已经是有序的了，只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 $O(n)$。
- 最坏情况：要排序的数据刚好是倒序排列的，需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 $O(n^2)$。

![Figure](C:/Users/xxnzj/Documents/GitHub/Algorithm/Resources/07.jpg)

- 平均情况 ：用 "有序度" 和 "逆序度" 分析代替平均复杂度分析.

对于包含 n 个数据的数组，这 n 个数据就有 n! 种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。比如前面举的那两个例子，其中一个要进行 6 次冒泡，而另一个只需要 4 次。

如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。这里还有一种思路，通过**"有序度"**和**"逆序度"**这两个概念来进行分析。

### 用 "有序度" 和 "逆序度" 来代替平均复杂度

#### 有序度

> 有序度是数组中具有有序关系的元素对的个数。

有序元素对用数学表达式表示：
$$
有序元素对 : 如果 i < j, a[i] <= a[j].
$$


![Figure](C:/Users/xxnzj/Documents/GitHub/Algorithm/Resources/08.jpg)

同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 $n*(n-1)/2$，也就是 15。把完全有序的数组的有序度叫作**满有序度**。

>满有序度推导：
>$$
>1+2 +...+n-1 = (1+2+..+n-1+n)-n=\frac{n(1+n)}{2}-n=\frac{n(n-1)}{2}
>$$

#### 逆序度

逆序度的定义正好跟有序度相反（默认从小到大为有序），关于逆序度，就不举例子讲了。可以对照有序度的例子自己看下。

逆序元素对用数学表达式表示：
$$
逆序元素对：a[i] > a[j], 如果i < j。
$$
关于这三个概念，还可以得到一个公式：
$$
逆序度 = 满有序度 - 有序度。
$$

### 分析前面举例的冒泡排序

要排序的数组的初始状态是 4，5，6，3，2，1 ，其中，有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。

n=6，所以排序完成之后终态的满有序度为 n*(n-1)/2=15。

![Figure](C:/Users/xxnzj/Documents/GitHub/Algorithm/Resources/09.jpg)

冒泡排序包含两个操作原子，**比较**和**交换**。每交换一次，有序度就加 1。<font color="red">不管算法怎么改进，交换次数总是确定的，即为**逆序度，也就是n*(n-1)/2–初始有序度**</font>。

此例中就是 15–3=12，要进行 12 次交换操作。

对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？

- 最坏情况：初始状态的有序度是 $0$，所以要进行$ n*(n-1)/2$ 次交换。
- 最好情况：初始状态的有序度是 $n*(n-1)/2$，就不需要进行交换。
- 平均情况：可以取个中间值 $n*(n-1)/4$，来表示初始有序度既不是很高也不是很低的平均情况。

换句话说，平均情况下，需要 $n*(n-1)/4$ 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 $O(n^2)$，所以平均情况下的时间复杂度就是 $O(n^2)$。

这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂，不太好用。等讲到快排的时候，还会再次用这种“不严格”的方法来分析平均时间复杂度。

# 插入排序 （Insertion Sort）

- 问题：一个有序的数组，往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，只要遍历数组，找到数据应该插入的位置将其插入即可。

![Figure](C:/Users/xxnzj/Documents/GitHub/Algorithm/Resources/10.jpg)

这是一个动态排序的过程，即动态地往有序集合中添加数据，可以通过这种方法保持集合中的数据一直有序。

对于一组静态数据，也可以借鉴上面讲的插入方法，来进行排序，于是就有了插入排序算法。

## 概念

>将数组中的数据分为两个区间，**已排序区间**和**未排序区间**。
>
>初始已排序区间只有一个元素，就是数组的第一个元素。
>
>插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。
>
>重复这个过程，直到未排序区间中元素为空，算法结束。



## 插入排序的实现

如图所示，要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。

![Figure](C:/Users/xxnzj/Documents/GitHub/Algorithm/Resources/11.jpg)

插入排序也包含两种操作，一种是**元素的比较**，一种是**元素的移动**。

当需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。

对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，**<font color="red">移动操作的次数总是固定的，就等于逆序度。</font>**

为什么说移动次数就等于逆序度呢？拿刚才的例子画了一个图表，一看就明白了。满有序度是 n*(n-1)/2=15，初始序列的有序度是 5，所以逆序度是 10。插入排序中，数据移动的个数总和也等于 10=3+3+4。

## 代码

```java
// java code

// 插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```

### 分析

**第一，插入排序是原地排序算法吗？**

从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。

**第二，插入排序是稳定的排序算法吗？**

在插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。

**第三，插入排序的时间复杂度是多少？**

如果要排序的数据已经是有序的，并不需要搬移任何数据。

如果从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 $O(n)$。

注意，这里是从尾到**头遍历已经有序的数据**。

如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为$ O(n^2)$。

还记得在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 $O(n)$。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 $O(n^2)$。



# 选择排序 （Selection Sort）

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

![Figure](C:/Users/xxnzj/Documents/GitHub/Algorithm/Resources/12.jpg)

## 代码

```java
// java code

// 选择排序，a表示数组，n表示数组大小
public void selectionSort(int[] a, int n) {
	if (n <= 1) return;

    // 有序区的末尾位置
    for(int i=0; i<n; i++)
    {
        int min=i;

        // 找出"a[i+1] ... a[n]"之间的最小元素，并赋值给min。
        for(int j=i+1; j<n; j++)
        {
            if(a[j] < a[min])
                min=j;
        }

        // 若min!=i，则交换 a[i] 和 a[min]。
        // 交换之后，保证了a[0] ... a[i] 之间的元素是有序的。
        if(min != i){
            int temp = a[i];
            a[i] = a[min];
            a[min] = a[i];
        }
    }
}
```



### 分析

**第一，插入排序是原地排序算法吗？**

选择排序空间复杂度为 $O(1)$，是一种原地排序算法。

**第二，插入排序是稳定的排序算法吗？**

选择排序是一种**不稳定**的排序算法。从前面画的那张图中，可以看出来，**选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置**，这样破坏了稳定性。

比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。

**第三，插入排序的时间复杂度是多少？**

选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 $O(n^2)$。



# 思考： 为什么插入排序比冒泡排序更受欢迎？

冒泡排序和插入排序的时间复杂度都是 O(n2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？

前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。

但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：

```java
// java code


// 冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

// 插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```

把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。

这个只是非常理论的分析，为了实验，针对上面的冒泡排序和插入排序的 Java 代码，可以用一个性能对比测试程序，随机生成 10000 个数组，每个数组中包含 200 个数据，然后在机器上分别用冒泡和插入排序算法来排序，冒泡排序算法大约 700ms 才能执行完成，而插入排序只需要 100ms 左右就能搞定！

所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 $O(n^2)$，但是如果希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间，现在只是讲了最基础的一种。如果对插入排序的优化感兴趣，可以自行学习一下**希尔排序**。



# 希尔排序：对插入排序的优化(待自己补充）



*`@ 笔记时间 ：2020-8-19	FROM	极客时间 《算法啊与数据结构之美》 王争  专栏`* 