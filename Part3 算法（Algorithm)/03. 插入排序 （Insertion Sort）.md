# 插入排序 （Insertion Sort）

- 问题：一个有序的数组，往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，只要遍历数组，找到数据应该插入的位置将其插入即可。

![Figure](E:/Document/GitHub/Algorithm/Resources/10.jpg)

这是一个动态排序的过程，即动态地往有序集合中添加数据，可以通过这种方法保持集合中的数据一直有序。

对于一组静态数据，也可以借鉴上面讲的插入方法，来进行排序，于是就有了插入排序算法。

## 概念

>将数组中的数据分为两个区间，**已排序区间**和**未排序区间**。
>
>初始已排序区间只有一个元素，就是数组的第一个元素。
>
>插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。
>
>重复这个过程，直到未排序区间中元素为空，算法结束。



## 插入排序的实现

如图所示，要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。

![Figure](E:/Document/GitHub/Algorithm/Resources/11.jpg)

插入排序也包含两种操作，一种是**元素的比较**，一种是**元素的移动**。

当需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。

对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，**<font color="red">移动操作的次数总是固定的，就等于逆序度。</font>**

为什么说移动次数就等于逆序度呢？拿刚才的例子画了一个图表，一看就明白了。满有序度是 n*(n-1)/2=15，初始序列的有序度是 5，所以逆序度是 10。插入排序中，数据移动的个数总和也等于 10=3+3+4。

## 代码

```java
// java code

// 插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```

### 分析

**第一，插入排序是原地排序算法吗？**

从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。

**第二，插入排序是稳定的排序算法吗？**

在插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。

**第三，插入排序的时间复杂度是多少？**

如果要排序的数据已经是有序的，并不需要搬移任何数据。

如果从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 $O(n)$。

注意，这里是从尾到**头遍历已经有序的数据**。

如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为$ O(n^2)$。

还记得在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 $O(n)$。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 $O(n^2)$。

*`@ 笔记时间 ：2020-8-19	FROM	极客时间 《算法啊与数据结构之美》 王争  专栏`* 