# 冒泡排序 （Bubble Sort）

## 概念

> 冒泡排序只会操作相邻的两个数据。
>
> 每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。
>
> 如果不满足就让它俩互换。
>
> 一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

## 举例说明

将一组数据 ： 4, 5, 6, 3, 2, 1 从 小到大进行排序。

- 第一次冒泡操作的详细过程：

  ![Figure](../Resources/04.jpg)

  经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。

- 要想完成所有数据的排序，只要进行 6 次这样的冒泡操作就行了：

  ![Figure](../Resources/05.jpg)

## 过程优化

**<font color="blue">当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作</font>。**

例子：下面给出要对 6 个元素进行冒泡排序，但是只需要 4 次冒泡操作就可以了。

![Figure](../Resources/06.jpg)

## 代码

```java
// java code
// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```

### 分析：

**第一，冒泡排序是原地排序算法吗？**

冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 $O(1)$，是一个原地排序算法。

**第二，冒泡排序是稳定的排序算法吗？**

在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

**第三，冒泡排序的时间复杂度是多少？**

- 最好情况：要排序的数据已经是有序的了，只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 $O(n)$。
- 最坏情况：要排序的数据刚好是倒序排列的，需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 $O(n^2)$。

![Figure](../Resources/07.jpg)

- 平均情况 ：用 "有序度" 和 "逆序度" 分析代替平均复杂度分析.

对于包含 n 个数据的数组，这 n 个数据就有 n! 种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。比如前面举的那两个例子，其中一个要进行 6 次冒泡，而另一个只需要 4 次。

如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。这里还有一种思路，通过**"有序度"**和**"逆序度"**这两个概念来进行分析。

### 用 "有序度" 和 "逆序度" 来代替平均复杂度

#### 有序度

> 有序度是数组中具有有序关系的元素对的个数。

有序元素对用数学表达式表示：
$$
有序元素对 : 如果 i < j, a[i] <= a[j].
$$


![Figure](../Resources/08.jpg)

同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 $n*(n-1)/2$，也就是 15。把完全有序的数组的有序度叫作**满有序度**。

>满有序度推导：
>$$
>1+2 +...+n-1 = (1+2+..+n-1+n)-n=\frac{n(1+n)}{2}-n=\frac{n(n-1)}{2}
>$$

#### 逆序度

逆序度的定义正好跟有序度相反（默认从小到大为有序），关于逆序度，就不举例子讲了。可以对照有序度的例子自己看下。

逆序元素对用数学表达式表示：
$$
逆序元素对：a[i] > a[j], 如果i < j。
$$
关于这三个概念，还可以得到一个公式：
$$
逆序度 = 满有序度 - 有序度。
$$

### 分析前面举例的冒泡排序

要排序的数组的初始状态是 4，5，6，3，2，1 ，其中，有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。

n=6，所以排序完成之后终态的满有序度为 n*(n-1)/2=15。

![Figure](../Resources/09.jpg)

冒泡排序包含两个操作原子，**比较**和**交换**。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为**逆序度，也就是n*(n-1)/2–初始有序度**。此例中就是 15–3=12，要进行 12 次交换操作。

对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？

- 最坏情况：初始状态的有序度是 $0$，所以要进行$ n*(n-1)/2$ 次交换。
- 最好情况：初始状态的有序度是 $n*(n-1)/2$，就不需要进行交换。
- 平均情况：可以取个中间值 $n*(n-1)/4$，来表示初始有序度既不是很高也不是很低的平均情况。

换句话说，平均情况下，需要 $n*(n-1)/4$ 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 $O(n^2)$，所以平均情况下的时间复杂度就是 $O(n^2)$。

这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂，不太好用。等讲到快排的时候，还会再次用这种“不严格”的方法来分析平均时间复杂度。







*`@ 笔记时间 ：2020-8-19	FROM	极客时间 《算法啊与数据结构之美》 王争  专栏`* 